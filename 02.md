# 하스켈 배움터 2일

## 프로젝트 만들기 (기본 템플릿인 hpack 버전)

```sh
$ stack --resolver lts-21.25 new hello
```

## REPL

`-- >>>` 으로 코드에서 값을 평가할 수도 있지만 다음과 같이 따로 REPL을 실행할 수 있다

```sh
$ stack repl
```

## 타입 변수

어떤 값을 인자로 받아 그대로 돌려주는 함수의 타입은?

```haskell
identity :: Int -> Int
identity x = x

identity :: String -> String
identity x = x
```

```haskell
identity :: a -> a
identity x = x
```

`a`은 타입 변수로 어떤 타입을 말하는 것이다. `a -> a`는 입력 타입과 출력 타입이 같다는 것을 말한다. 

```haskell
identity :: any -> any
identity x = x
```

`a` 대신 소문자로 시작하는 아무 글자를 써도 된다.

인자 두 개를 받아서 두 번째 값을 돌려주는 함수

```haskell
second :: a -> b -> b
second x y = y
```

`a`, `b`를 썼기 때문에 두 인자 타입은 달라도 된다. 하지만 결과는 두번째 인자 타입과 같아야 한다

## 타입 클래스

더하기 함수 `(+)`는 어떻게 `Int`와 `Double`을 함께 처리할까?

```haskell
int :: Int
int = 1 + 1

double :: Double
double = 2.0 + 3.0
```

`(+) :: Int -> Int -> Int`와 `(+) :: Double -> Double -> Double` 둘 다 처리할 수 있는 다형적 함수이다.

`(+)`의 실제 타입에 대해 알아보기, REPL에서 `:t` 뒤에 값을 쓰면 타입이 나온다. 

```haskell
-- >>> :t (+)
-- (+) :: Num a => a -> a -> a
```

어떤 타입 `a` 인자 두 개를 받아 같은 타입의 `a`를 돌려준다. 하지만 `a` 타입은 `Num` 이라는 제약이 있다. 여기서 `Num`을 
타입 클래스라고 한다. 

`Int`나 `Double`은 `Num` 타입 클래스 제약을 따르고 있기 때문에 쓸 수 있다. 제약을 따른 다는 것은 타입 클래스의 인스턴스가 
있다고 말한다.

`:info` 뒤에 타입을 쓰면 타입에 대한 자세한 내용이 나온다

```haskell
-- >>> :info Int
-- type Int :: *
-- data Int = I# Int#
--   	-- Defined in ‘GHC.Types’
-- instance Bounded Int -- Defined in ‘GHC.Enum’
-- instance Enum Int -- Defined in ‘GHC.Enum’
-- instance Integral Int -- Defined in ‘GHC.Real’
-- instance Num Int -- Defined in ‘GHC.Num’
-- instance Ord Int -- Defined in ‘GHC.Classes’
-- instance Read Int -- Defined in ‘GHC.Read’
-- instance Real Int -- Defined in ‘GHC.Real’
-- instance Eq Int -- Defined in ‘GHC.Classes’
-- instance Show Int -- Defined in ‘GHC.Show’
```

`Int`는 `Enum`, `Show`등 여러 타입 클래스의 인스턴스가 있는 것을 볼 수 있다. 타입 클래스는 타입 클래스가 선언된 곳이나 
타입이 선언된 곳에서 인스턴스를 만들지 않아도 되기 때문에 확장성이 좋다. 사용하는 곳에서 인스턴스가 구현된 모듈을 import 하면
된다. (* 인스턴스를 따로 export 할 필요는 없다)

### 실습 1

`Int`와 `Double`등 `Num` 타입 클래스의 인스턴스가 있다면 `1`을 증가시키는 `inc` 함수를 정의하고 구현하기, 힌트 타입 
제약은 `(+)` 함수의 시그니처를 참고!

### 타입 클래스 인스턴스 만들기

어떤 타입 클래스 인스턴스는 `instance` 구문으로 만들 수 있다.

```haskell
instance 타입클래스이름 타입이름 where
  함수 = 구현
  함수 = 구현
  ...
```

예를 들어 `Num` 타입 클래스는 `(+)` 함수를 구현해야 한다. `MyValue`라는 나만의 타입을 만들고 `(+)`를 쓰기 위해 다음과
같이 인스턴스를 만들 수 있다. `Num`이 요구하는 함수를 다 구현해야 하지만 구현하지 않아도 컴파일러 경고가 나지만 컴파일은 되고 
만약 사용한다면 런타임 에러가 난다.

```haskell
value1 :: MyValue
value1 = MyValue 1

value2 :: MyValue
value2 = MyValue 2

instance Num MyValue where
  (+) (MyValue x) (MyValue y) = MyValue (x + y)
  -- 나머지는 구현하지 않아서 컴파일러가 경고를 준다

value :: MyValue
value = value1 + value2
```

### 실습 2

`x`와 `y` 좌표를 갖는 `Point` 레코드 타입을 만들고 두 `Point`에 `(+)`를 사용할 수 있게 `Num` 인스턴스를 만들기
더하는 방법은 `x` 값과 `y` 값을 각각 더하기

### 타입 클래스 선언하기

`class` 구문으로 타입 클래스를 정의 할 수 있다.

```haskell
class 타입클래스이름 타입변수 where
  값 :: 타입
  ...
```

### 실습 3

다음과 같은 `YesNo` 타입 클래스를 정의하고 `Int`, `Bool`, `리스트` 타입에 대해 각각 인스턴스를 만들기

```haskell
class YesNo a where
    yesno :: a -> Bool
```

`yesno`는 `Int`인 경우 `0`일 때만 `False`, `Bool`인 경우 `False`면 `False`, `리스트`은 `[]`면 `True` 
나머지는 `False`

### 타입 클래스의 기본 구현 

타입 클래스는 기본 구현을 갖을 수 있다. 기본 구현이 있다면 인스턴스를 만들 때 구현해주지 않아도 된다.

```haskell
class YesNo a where
    yesno :: a -> Bool
    yesno _ = False
```

위와 같이 `yesno`의 기본 구현을 무조건 `False`로 해주면 `YesNo` 인스턴스를 만들 때 `yesno` 함수를 구현하지 않아도 된다.

## Deriving

내가 만든 타입을 출력하려면 출력하는 방법을 모르기 때문에 에러가 난다

```haskell
data Point = Point Float Float

-- >>> Point 1.0 2.0
-- No instance for (Show Point) arising from a use of ‘evalPrint’

-- >>> print $ Point 1.0 2.0
-- No instance for (Show Point) arising from a use of `print'
```

모두 `Show` 타입 클래스의 인스턴스가 없기 때문이다. `Show` 타입 클래스에는 `show` 함수가 있는데 `a -> String` 어떤 
값을 문자열로 바꿔주는 함수이다.

```haskell
class Show a where
  show :: a -> String
  ...
```

## 실습 4

위 `Point` 타입의 `Show` 타입 클래스를 만들어 `main` 함수에서 `print` 함수로 출력해보세요. 문자열은 `(++)` 함수로 합칠
수 있다.

### deriving

타입을 정의할 때 마지막에 `deriving (타입클래스)`를 써주면 자동으로 인스턴스가 생긴다. 자동으로 만들 수 있는 이유는 타입 
클래스의 기본 구현을 사용한다. 

```haskell
data Point = Point Double Double deriving (Show)

-- >>> Point 1.0 1.0
-- Point 1.0 1.0
```

기본적으로 하스켈에 정의된 타입 클래스에 대해 deriving 할 수 있고 `DeriveAnyClass` 언어 확장을 사용하면 사용자가 만든 
타입 클래스도 deriving 할 수 있다.

```haskell
{-# LANGUAGE DeriveAnyClass #-}

module Main where

class YesNo a where
  yesno :: a -> Bool
  yesno _ = False

data Point = Point Double Double deriving (Show, YesNo)
```

### 언어 확장

모듈의 가장 위에 `{-# LANGUAGE 언어확장 #-}`으로 GHC 언어 확장을 활성화 수 있다. 하스켈 컴파일러마다 지원하는 언어 확장이
다르기 때문에 언어 확장은 하스켈 표준이라고 할 수 없지만 대부분 GHC 컴파일러를 쓰기 때문에 언어 확장을 많이 사용한다. 항상
언어 확장을 활성화 하려면 `package.yaml` 파일을 쓰는 경우 `default-extensions`키에 정의할 수 있다. 자주 사용하는 언어 
확장은 다음과 같다. 설명은 필요할 때 하도록 하겠다.

```text
ConstraintKinds
DeriveGeneric
DerivingStrategies
GeneralizedNewtypeDeriving
InstanceSigs
KindSignatures
LambdaCase
OverloadedStrings
RecordWildCards
ScopedTypeVariables
StandaloneDeriving
TupleSections
TypeApplications
ViewPatterns
```

## 펑터와 타입 생성자

### 실습 5

`Null`이거나 `Int` 값을 같는 타입 `OptionalInt` 타입을 정의하기

### 실습 6

`OptionalInt` 두 개를 더 할 수 있게 `Num` 인스턴스를 만들고 `(+)` 함수로 더하기, 하나라도 `Null`이면 결과는 `Null`

### OptionalInt의 일반화

```haskell
data Optional a = Value a 
                | Null 
                deriving (Show)
```

`Optional`은 타입이 아니고 타입 변수(`a`) 한 개를 받는 타입 생성자이다. `Optional Int`는 타입이다.
(타입 레벨 관점에서 Kind는 `* -> *` 또는 `Type -> Type`, 뒤에서 다룰 예정)

### 실습 7

일반화 된 `Optional`의 `(+)` 인스턴스 만들기

### Optional 사용하기

### 실습 8

* 아래 `inc` 함수를 사용해서 `Optional a` 타입에 쓸 수 있는 `incOptional`를 구현하시오. `a`는 `Num` 인스턴스가 필요
  `Null` 값일 때는 결과가 `Null`

  ```haskell
  inc :: (Num a) => a -> a
  inc = (1 +)
  ```

* 아래 `hello` 함수를 사용해서 `Optional String` 타입에 `helloOptionalString` 함수를 정의하고 구현하시오.

  ```haskell
  hello :: String -> String
  hello = ("Hello " ++)
  ```

### 공통 기능의 일반화

#### 실습 9

`incOptional`와 `helloOptional`는 Optional로 감싸있는 값에 Null이 아닐 때만 일반 함수를 적용하는 공통 코드가 있다.
이 코드를 일반화 한 `mapOptional` 함수를 구현해보자.

```haskell
mapOptional :: (a -> b) -> Optional a -> Optional b
```

`mapOptional`과 `inc`, `hello`를 적용해 `incOptional`, `helloOptionalString`를 사용해보라

### 타입 생성자와 리스트

리스트 타입인 `[]`도 사실 타입 생성자의 특별한 형태이다. `data List a = ...` 대신 `data [] a = ...`라고 볼 수 있고
실제 표기는 `[a]` 형태로 한다. 따라서 리스트 타입도 타입 변수가 하나 있는 타입 생성자이다.


### 실습 10

`mapOptional`은 타입 변수가 하나인 `Optional` 타입 생성자로 감싸있는 어떤 타입 `a`를 일반 함수를 적용해 `b`로 바꿀 수 
있는 함수였다. 이때 값이 `Null`이면 결과가 `Null`인 효과가 있었다. 마찬가지로 타입 변수가 하나인 `[]` 타입 생성자로 감싸있는 
`a` 타입에 일반 함수를 적용해 `b`로 바꾸는 함수를 만들 수 있다. `[]`의 특별한 효과는 항목에 모두 일반 함수를 적용하는 것이다.
다음 함수를 구현해보라. (힌트 지난 시간에 리스트 `map` 함수를 배웠다)

```haskell
mapList :: (a -> b) -> [a] -> [b]
```

### 펑터의 정의

`mapOptional`과 `mapList`는 비슷한 타입이다. 물론 구현은 다르다. 이 타입은 타입 변수가 하나인 어떤 타입 생성자에도 쓸 수 
있을 것같다. 타입 변수가 하나인 타입 생성자를 변수화 시키면 다음과 같은 추상을 얻을 수 있다.

```haskell
amap :: (a -> b) -> f a -> f b
```

이 함수에 `f` 변수를 타입 클래스로 추상화 하면 다음과 같은 타입 클래스를 정의 할 수 있다.

```haskell
class Mapable f where
	amap :: (a -> b) -> f a -> f b 
```

이제 어떤 타입 생성자 `f`에 `Mapable` 인스턴스가 있다면 `amp`을 사용할 수 있다. `amap`은 `f`로 감싼 타입 `a`에 일반 함수
를 적용해 `b`를 얻으면서 특별한 효과를 줄 수 있다. (Optional은 Null이 아닐 때만, []는 모든 항목에 적용)

### 실습 11

* `Optional` 타입 생성자의 `Mapable` 인스턴스를 만들기, 구현은 `mapOptional`과 같다.
* `[]` 타입 생성자의 `Mapable` 인스턴스 만들기, 구현은 `mapList`와 같다.

### 문제

`Int` 타입도 `Mapable` 인스턴스를 만들 수 있을까?

### 진짜 펑터와 Maybe 타입

하스켈에서 `Mapable`과 같은 타입클래스를 `Functor`라고 한다. 다음과 같이 비슷하게 정의 되어 있다.

```haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b 
```

또 `Optional`은 하스켈에 `Maybe`로 다음과 같이 정의되어 있고 `Functor` 인스턴스도 있다. `[]` 역시 `Functor` 인스턴스가
있다.

```haskell
data Maybe a = Just a | Nothing
```

```haskell
-- >>> fmap inc (Just 1)
-- Just 2

-- >>> fmap inc Nothing
-- Nothing

-- >>> fmap (prefix "Hello") $ Just "World"
-- Just "Hello World"

-- >>> fmap inc [1, 2, 3]
-- [2,3,4]
```

`Functor`는 하스켈에서 중위 함수인 `<$>`로 많이 쓴다.

```haskell
-- >>> inc <$> (Just 1)
-- Just 2

-- >>> inc <$> [1, 2, 3]
-- [2,3,4]
```

### Either 타입

`Maybe` 타입은 어떤 계산 결과에 값이 없는 경우 많이 쓴다. `Maybe`와 마찬가지로 어떤 계산 결과가 올바르지 않은 경우에 오류
내용과 함께 전달 할 수 있는 `Either` 타입도 많이 쓴다. `Either` 타입은 다음과 같이 생겼다.

```haskell
data Either a b = Left a | Right b
```

```haskell
failValue :: Either String Int
failValue = Left "Invalid Number"

successValue :: Either String Int
successValue = Right 1
```

`Either`도 `Functor` 인스턴스가 있기 때문에 에러가 아닐 때(효과) 일반 함수를 적용할 수 있다. 

```haskell
-- >>> inc <$> successValue
-- Right 2

-- >>> inc <$> failValue
-- Left "Invalid Number"
```

### 생각해보기

펑터 타입 클래스의 `fmap`은 다음과 같이 정의 되어 있다. 정의 따르면 `f a`이기 때문에 `f`는 타입 변수가 하나 있어야 한다.
하지만 `Either`는 타입 변수가 두 개이다. 어떻게 `Functor` 인스턴스를 만들 수 있었을까?

```haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b 
```

## 모나드

모나드 예제를 알아보기 전에 하스켈에서 키와 값으로 데이터를 만들고 키로 값을 조회할 수 있는 방법에 대해 알아보자

하스켈은 튜플의 리스트를 다른 언어의 맵처럼 쓸 수 있다.

```haskell
ids :: [(String, Int)]
ids = [("Todd", 32), ("Eunmin", 424)]

-- >>> lookup "Todd" ids
-- Just 32
```

튜플의 첫번째 항목을 키로 `lookup` 함수를 부르면 Maybe 두번째타입 형태로 나온다. 키에 연결된 값이 없다면 `Nothing` 값이
나온다

### 실습 12

위에 `ids`에 들어 있는 값은 이름과 아이디 쌍이라고 하고 다음과 같이 아이디에 해당하는 나이가 있는 `ages` 데이터가 있다.

이 때 이름으로 나이를 조회할 수 있는 `getAge :: String -> Maybe Int` 함수를 구현하라. 이름에 해당하는 아이디가 없어나, 
아이디에 해당하는 나이가 없다면 `Nothing`을 돌려줘야 한다.

```haskell
ages :: [(Int, Int)]
ages = [(32, 100), (42, 50)]
```

### 펑터의 한계

위 실습 12에 펑터를 사용할 수 있을까?

```haskell

getAge :: String -> Maybe Int
getAge name = fmap (\id -> lookup id ages) (lookup name ids) -- 컴파일 에러!
```

펑터는 `lookup`의 결과에 다시 `lookup`을 적용할 수 없다. 왜냐하면 펑터에 쓸 수 있는 함수는 `a -> b`인 일반 함수이기
때문이다. 만약 `a -> b` 대신 `a -> f b`를 쓸 수 있다면 연속 적용할 수 있다. 모나드는 바로 다음과 같은 타입 클래스를 갖는다고
할 수 있다. 타입 변수는 모나드라는 이름 때문에 `f` 대신 `m`으로 썼다.

```haskell
class Monad m where
  bind :: (a -> m b) -> m a -> m b
```

이 함수는 `bind`라고 부르지만 실제 하스켈에서는 중위 함수로 되어 있다. 

```haskell
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
```

연속 적용의 편의를 위해 앞 쪽에 `m a` 뒤에 `a -> m b`를 뒀다. `Maybe` 타입의 모나드도 이미 구현되어 있기 때문에
`getAge`는 다음과 같이 만들 수 있다. `(>>=)`는 낮은 연산자 우선 순위를 갖고 있기 때문에 가장 나중에 계산되고 그래서 괄호
없이 쓸 수 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup name ids >>= \id -> lookup id ages
```

위 함수에서 만약 `lookup` 함수의 인자 순서가 반대라면 함수 부분 적용을 통해 아래와 같이 쓸 수 있었을 것이다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup ids name >>= lookup ages -- 컴파일 안됨!
```

하스켈에 편의 함수 중 인자 순서를 바꿔서 적용해주는 `flip`이라는 유틸리티 함수가 있다. 그것을 사용하면 아래와 같이 쓸 수 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup name ids >>= flip lookup ages 
```

### 모나드의 좋은 점

펑터보다 모나드가 더 유연하고 좋다. 모나드 대신 펑터를 쓸 수 없지만 펑터 대신 모나드를 쓸 수 있다.

```haskell
-- >>> fmap (\x -> inc x) $ Just 1
-- Just 2

-- >>> Just 1 >>= (\x -> Just (inc x))
-- Just 2
```

모나드 안에서 일반 함수를 쓰되 결과 값을 Just로 감싸주면 되기 때문이다. 어떤 모나드에서 일반 함수를 쓸 때 일반 값을 모나드 값
으로 바꿀 때가 많기 때문에 모나드 타입 클래스에는 `return`이라는 함수가 있다.

```haskell
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
```

`return`은 일반 값을 받아서 모나드로 감싼 값을 만들어 준다. `Maybe` 모나드 값이라면 `return 1` 했을 때 `Just 1`이 된다.
그래서 위 예제는 다음과 같이 일반화 해서 쓸 수 있다. (* 주의, 자바같은 언어의 return과 이름만 같다)

```haskell
-- >>> Just 1 >>= (\x -> Just (inc x))
-- Just 2

-- >>> Just 1 >>= (\x -> return (inc x))
-- Just 2
```

### 실습 13

다음 값들을 이용해서 모나드를 활용해 `id` 값에 `inc`를 적용해 나이를 가져오는 `getAge'` 함수를 만들어라

```haskell
inc :: (Num a) -> a -> a
inc x = x + 1

ids :: [(String, Int)]
ids = [("Todd", 32), ("Eunmin", 424)]

ages :: [(Int, Int)]
ages = [(33, 100), (423, 50)]
```

### 실습 14

리스트도 모나드 인스턴스가 있다. 모나드를 이용해 숫자를 입력 받아 모든 항목에 `inc`를 적용하고 다시 모든 항목에 `show`를 
적용하는 `foo` 함수를 구현하라.

```haskell
foo :: [Int] -> [String]
```

### 맥락을 이어갈 수 있는 모나드

모나드는 펑터와 다르게 계산을 연속으로 이어나갈 수 있다. 그리고 연속된 계산에 효과(Maybe의 경우 Nothing이면 더 이상 계산하지 
않음)를 갖는다. 효과는 연속된 계산에 연속성을 갖을 수 있기 때문에 모나드는 맥락(Context)이 있다고 볼 수 있다. `(>>=)` 함수는
맥락에 따라 다른 동작을 한다.

### 모나드 편의 문법

모나드를 많이 쓰는 하스켈과 스칼라 언어에서는 모나드를 위한 문법 구문을 제공한다. 하스켈에서는 `do`, 스칼라에서는 `for`라고 한다.
다음은 위 실습 14 예제를 `do` 구문으로 바꿔쓴 것이다.

```haskell
getAge :: String -> Maybe Int
getAge name = do
  id <- lookup name ids
  id <- Just (inc id)
  lookup id ages
```

`do` 구문 안에서는 `let 이름 = 값`으로 중간 계산 결과에 이름을 붙일 수 있는 편리한 기능도 있습니다.

```haskell
getAge :: String -> Maybe Int
getAge name = do
  id <- lookup name ids
  let result = inc id
  id <- Just result -- 조금 억지스러운 예제이긴 합니다
  lookup id ages
```

## 실습 15

`ages`에서 아이디 두 개를 받아서 나이를 합치는 `sumAges` 함수를 작성하라

```haskell
sumAges :: Int -> Int -> Maybe Int
```

## 어플리커티브

위 실습 15에서 `sumAges`는 사실 앞의 계산과 뒤의 계산이 독립적이기 때문에 꼭 모나드를 쓸 필요가 없다. 이런 경우 어플리커티브
펑터를 사용하면 좋다. 다음은 `Applicative` 타입 클래스에 있는 `apply`라고 부르는 함수다.

```haskell
class Applicative f where
  (<*>) :: f (a -> b) -> f a -> f b
```

펑터와 비교해 봅시다.

```haskell
(<$>) :: (a -> b) -> f a -> f b
```

비슷하지만 일반 함수를 `f`로 감싼 타입입니다. 그렇다면 사용은 다음과 같이 할 수 있다.

```haskell
-- >>> (+1) <$> Just 1
-- Just 2

-- >>> Just (+1) <*> Just 1
-- Just 2
```

직관적으로 이해하기 어렵지만, 기억하면 좋을 것은 일반 함수를 쓰는데 인자 값들이 감싼 타입일 때 쓰면 좋다. `sumAges`는
`(+)`를 적용하는데 인자가 `Maybe Int`였기 때문에 어플리커티브를 쓰기 적절하다. 일반 함수를 `f (a -> b)`로 만들 때
보통 첫번째 인자에 펑터를 적용해서 다음과 같이 사용할 수 있다.

```haskell
sumAges :: Int -> Int -> Maybe Int
sumAges id1 id2 :: (+) <$> lookup id1 ages <*> lookup id2 ages
```

차근차근 보면 다음과 같다. `(+) <$> lookup id1 ages`는 무슨 타입인가? `\x y -> x + y <$> Maybe Int`일 것이다.
`Int` 타입은 `x`에 들어간다면 결과는 `x`가 부분 적용된 함수이다. 펑터의 결과는 일반 함수에 다시 `f`로 감싼 것이기 때문에 
결과 `(+)`의 나머지 인자를 받는 함수에 `Maybe`가 씌워진 `Maybe (Int -> Int)` 타입이 된다.

어플리커티브 타입 클래스에 많이 쓰는 함수 중 하나는 `pure`이다. `pure`는 모나드의 `return`과 같다. 많은 사람들이 `return`
보다 `pure`를 선호하는 것 같다. 이것이 조금 더 일반적인 버전이기 때문같다. 왜냐하면 `Monad`가 되려면 타입 생성자가 
`Applicative`여야 하는 제약이 있기 때문이다.

```haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
  ...
```

또 `Applicative`는 `Fuctor` 인스턴스가 있어야하는 제약이 있다.

```haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  ...
```

`Functor`는 다른 제약은 없다.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  ...
```

## 세미그룹

세미그룹은 효과와 직접적으로 관계는 없는 타입 클래스입니다. `Semigroup` 타입 클래스는 뭔가 합칠 수 있는 것들에 대한 추상입니다.
대표적인 인스턴스로 리스트 타입이 있습니다. 

```haskell
class Semigroup m where
  (<>) :: m -> m -> m
  ...
```

`String`도 리스트이기 때문에 다음과 같이 합칠 수 있습니다.

```haskell
-- >>> "Hello" <> " " <> "World"
-- "Hello World"
```

## 모노이드

모노이드는 세미그룹에 `mempty`가 있는 형태입니다. 세미그룹과 활용하여 `mempty`를 초기 값으로 활요할 수 있습니다.
`mappend`는 `(<>)`와 같지만 보통 `(<>)`를 많이 씁니다. 

```haskell
class Semigroup m => Monoid m where
  mempty :: m
  mappend :: a -> a -> a
```

리스트이 `mempty`는 `()` 빈 리스트입니다. 

```haskell
value :: [Int]
value = mempty [1, 2, 3]

-- >>> value
-- []
```

## Traverse

다음 값이 있을 때,

```haskell
ids :: [(String, Int)]
ids = [("John", 1), ("Jane", 2), ("Jim", 3)]

names :: [String]
names = ["John", "Jane", "Jim"]
```

다음 함수를 만들어라

```haskell
ages :: [Maybe Int]
```

그리고 다음 함수에 대해 생각해보시오.

```haskell
ages' :: Maybe [Int]
```

## Reader 모나드

## Writer 모나드

## State 모나드