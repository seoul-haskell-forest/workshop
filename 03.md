# 하스켈 배움터 3일

## 펑터

### 타입 생성자와 리스트

리스트 타입인 `[]`도 사실 타입 생성자의 특별한 형태이다. `data List a = ...` 대신 `data [] a = ...`라고 볼 수 있고
실제 표기는 `[a]` 형태로 한다. 따라서 리스트 타입도 타입 변수가 하나 있는 타입 생성자이다.


### 실습 10

`mapOptional`은 타입 변수가 하나인 `Optional` 타입 생성자로 감싸있는 어떤 타입 `a`를 일반 함수를 적용해 `b`로 바꿀 수 
있는 함수였다. 이때 값이 `Null`이면 결과가 `Null`인 효과가 있었다. 마찬가지로 타입 변수가 하나인 `[]` 타입 생성자로 감싸있는 
`a` 타입에 일반 함수를 적용해 `b`로 바꾸는 함수를 만들 수 있다. `[]`의 특별한 효과는 항목에 모두 일반 함수를 적용하는 것이다.
다음 함수를 구현해보라. (힌트 지난 시간에 리스트 `map` 함수를 배웠다)

```haskell
mapList :: (a -> b) -> [a] -> [b]
```

### 펑터의 정의

`mapOptional`과 `mapList`는 비슷한 타입이다. 물론 구현은 다르다. 이 타입은 타입 변수가 하나인 어떤 타입 생성자에도 쓸 수 
있을 것같다. 타입 변수가 하나인 타입 생성자를 변수화 시키면 다음과 같은 추상을 얻을 수 있다.

```haskell
amap :: (a -> b) -> f a -> f b
```

이 함수에 `f` 변수를 타입 클래스로 추상화 하면 다음과 같은 타입 클래스를 정의 할 수 있다.

```haskell
class Mapable f where
	amap :: (a -> b) -> f a -> f b 
```

이제 어떤 타입 생성자 `f`에 `Mapable` 인스턴스가 있다면 `amp`을 사용할 수 있다. `amap`은 `f`로 감싼 타입 `a`에 일반 함수
를 적용해 `b`를 얻으면서 특별한 효과를 줄 수 있다. (Optional은 Null이 아닐 때만, []는 모든 항목에 적용)

### 실습 11

* `Optional` 타입 생성자의 `Mapable` 인스턴스를 만들기, 구현은 `mapOptional`과 같다.
* `[]` 타입 생성자의 `Mapable` 인스턴스 만들기, 구현은 `mapList`와 같다.

### 문제

`Int` 타입도 `Mapable` 인스턴스를 만들 수 있을까?

### 진짜 펑터와 Maybe 타입

하스켈에서 `Mapable`과 같은 타입클래스를 `Functor`라고 한다. 다음과 같이 비슷하게 정의 되어 있다.

```haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b 
```

또 `Optional`은 하스켈에 `Maybe`로 다음과 같이 정의되어 있고 `Functor` 인스턴스도 있다. `[]` 역시 `Functor` 인스턴스가
있다.

```haskell
data Maybe a = Just a | Nothing
```

```haskell
-- >>> fmap inc (Just 1)
-- Just 2

-- >>> fmap inc Nothing
-- Nothing

-- >>> fmap (prefix "Hello") $ Just "World"
-- Just "Hello World"

-- >>> fmap inc [1, 2, 3]
-- [2,3,4]
```

`Functor`는 하스켈에서 중위 함수인 `<$>`로 많이 쓴다.

```haskell
-- >>> inc <$> (Just 1)
-- Just 2

-- >>> inc <$> [1, 2, 3]
-- [2,3,4]
```

### Either 타입

`Maybe` 타입은 어떤 계산 결과에 값이 없는 경우 많이 쓴다. `Maybe`와 마찬가지로 어떤 계산 결과가 올바르지 않은 경우에 오류
내용과 함께 전달 할 수 있는 `Either` 타입도 많이 쓴다. `Either` 타입은 다음과 같이 생겼다.

```haskell
data Either a b = Left a | Right b
```

```haskell
failValue :: Either String Int
failValue = Left "Invalid Number"

successValue :: Either String Int
successValue = Right 1
```

`Either`도 `Functor` 인스턴스가 있기 때문에 에러가 아닐 때(효과) 일반 함수를 적용할 수 있다. 

```haskell
-- >>> inc <$> successValue
-- Right 2

-- >>> inc <$> failValue
-- Left "Invalid Number"
```

### 생각해보기

펑터 타입 클래스의 `fmap`은 다음과 같이 정의 되어 있다. 정의 따르면 `f a`이기 때문에 `f`는 타입 변수가 하나 있어야 한다.
하지만 `Either`는 타입 변수가 두 개이다. 어떻게 `Functor` 인스턴스를 만들 수 있었을까?

```haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b 
```

## 모나드

모나드 예제를 알아보기 전에 하스켈에서 키와 값으로 데이터를 만들고 키로 값을 조회할 수 있는 방법에 대해 알아보자

하스켈은 튜플의 리스트를 다른 언어의 맵처럼 쓸 수 있다.

```haskell
ids :: [(String, Int)]
ids = [("Todd", 32), ("Eunmin", 424)]

-- >>> lookup "Todd" ids
-- Just 32
```

튜플의 첫번째 항목을 키로 `lookup` 함수를 부르면 Maybe 두번째타입 형태로 나온다. 키에 연결된 값이 없다면 `Nothing` 값이
나온다

### 실습 12

위에 `ids`에 들어 있는 값은 이름과 아이디 쌍이라고 하고 다음과 같이 아이디에 해당하는 나이가 있는 `ages` 데이터가 있다.

이 때 이름으로 나이를 조회할 수 있는 `getAge :: String -> Maybe Int` 함수를 구현하라. 이름에 해당하는 아이디가 없어나, 
아이디에 해당하는 나이가 없다면 `Nothing`을 돌려줘야 한다.

```haskell
ages :: [(Int, Int)]
ages = [(32, 100), (42, 50)]
```

### 펑터의 한계

위 실습 12에 펑터를 사용할 수 있을까?

```haskell

getAge :: String -> Maybe Int
getAge name = fmap (\id -> lookup id ages) (lookup name ids) -- 컴파일 에러!
```

펑터는 `lookup`의 결과에 다시 `lookup`을 적용할 수 없다. 왜냐하면 펑터에 쓸 수 있는 함수는 `a -> b`인 일반 함수이기
때문이다. 만약 `a -> b` 대신 `a -> f b`를 쓸 수 있다면 연속 적용할 수 있다. 모나드는 바로 다음과 같은 타입 클래스를 갖는다고
할 수 있다. 타입 변수는 모나드라는 이름 때문에 `f` 대신 `m`으로 썼다.

```haskell
class Monad m where
  bind :: (a -> m b) -> m a -> m b
```

이 함수는 `bind`라고 부르지만 실제 하스켈에서는 중위 함수로 되어 있다. 

```haskell
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
```

연속 적용의 편의를 위해 앞 쪽에 `m a` 뒤에 `a -> m b`를 뒀다. `Maybe` 타입의 모나드도 이미 구현되어 있기 때문에
`getAge`는 다음과 같이 만들 수 있다. `(>>=)`는 낮은 연산자 우선 순위를 갖고 있기 때문에 가장 나중에 계산되고 그래서 괄호
없이 쓸 수 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup name ids >>= \id -> lookup id ages
```

위 함수에서 만약 `lookup` 함수의 인자 순서가 반대라면 함수 부분 적용을 통해 아래와 같이 쓸 수 있었을 것이다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup ids name >>= lookup ages -- 컴파일 안됨!
```

하스켈에 편의 함수 중 인자 순서를 바꿔서 적용해주는 `flip`이라는 유틸리티 함수가 있다. 그것을 사용하면 아래와 같이 쓸 수 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup name ids >>= flip lookup ages 
```

### 모나드의 좋은 점

펑터보다 모나드가 더 유연하고 좋다. 모나드 대신 펑터를 쓸 수 없지만 펑터 대신 모나드를 쓸 수 있다.

```haskell
-- >>> fmap (\x -> inc x) $ Just 1
-- Just 2

-- >>> Just 1 >>= (\x -> Just (inc x))
-- Just 2
```

모나드 안에서 일반 함수를 쓰되 결과 값을 Just로 감싸주면 되기 때문이다. 어떤 모나드에서 일반 함수를 쓸 때 일반 값을 모나드 값
으로 바꿀 때가 많기 때문에 모나드 타입 클래스에는 `return`이라는 함수가 있다.

```haskell
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
```

`return`은 일반 값을 받아서 모나드로 감싼 값을 만들어 준다. `Maybe` 모나드 값이라면 `return 1` 했을 때 `Just 1`이 된다.
그래서 위 예제는 다음과 같이 일반화 해서 쓸 수 있다. (* 주의, 자바같은 언어의 return과 이름만 같다)

```haskell
-- >>> Just 1 >>= (\x -> Just (inc x))
-- Just 2

-- >>> Just 1 >>= (\x -> return (inc x))
-- Just 2
```

### 실습 13

다음 값들을 이용해서 모나드를 활용해 `id` 값에 `inc`를 적용해 나이를 가져오는 `getAge'` 함수를 만들어라

```haskell
inc :: (Num a) -> a -> a
inc x = x + 1

ids :: [(String, Int)]
ids = [("Todd", 32), ("Eunmin", 424)]

ages :: [(Int, Int)]
ages = [(33, 100), (423, 50)]
```

### 실습 14

리스트도 모나드 인스턴스가 있다. 모나드를 이용해 숫자를 입력 받아 모든 항목에 `inc`를 적용하고 다시 모든 항목에 `show`를 
적용하는 `foo` 함수를 구현하라.

```haskell
foo :: [Int] -> [String]
```

### 맥락을 이어갈 수 있는 모나드

모나드는 펑터와 다르게 계산을 연속으로 이어나갈 수 있다. 그리고 연속된 계산에 효과(Maybe의 경우 Nothing이면 더 이상 계산하지 
않음)를 갖는다. 효과는 연속된 계산에 연속성을 갖을 수 있기 때문에 모나드는 맥락(Context)이 있다고 볼 수 있다. `(>>=)` 함수는
맥락에 따라 다른 동작을 한다.

### 모나드 편의 문법

모나드를 많이 쓰는 하스켈과 스칼라 언어에서는 모나드를 위한 문법 구문을 제공한다. 하스켈에서는 `do`, 스칼라에서는 `for`라고 한다.
다음은 위 실습 14 예제를 `do` 구문으로 바꿔쓴 것이다.

```haskell
getAge :: String -> Maybe Int
getAge name = do
  id <- lookup name ids
  id <- Just (inc id)
  lookup id ages
```

`do` 구문 안에서는 `let 이름 = 값`으로 중간 계산 결과에 이름을 붙일 수 있는 편리한 기능도 있습니다.

```haskell
getAge :: String -> Maybe Int
getAge name = do
  id <- lookup name ids
  let result = inc id
  id <- Just result -- 조금 억지스러운 예제이긴 합니다
  lookup id ages
```

## 실습 15

`ages`에서 아이디 두 개를 받아서 나이를 합치는 `sumAges` 함수를 작성하라

```haskell
sumAges :: Int -> Int -> Maybe Int
```

## 어플리커티브

위 실습 15에서 `sumAges`는 사실 앞의 계산과 뒤의 계산이 독립적이기 때문에 꼭 모나드를 쓸 필요가 없다. 이런 경우 어플리커티브
펑터를 사용하면 좋다. 다음은 `Applicative` 타입 클래스에 있는 `apply`라고 부르는 함수다.

```haskell
class Applicative f where
  (<*>) :: f (a -> b) -> f a -> f b
```

펑터와 비교해 봅시다.

```haskell
(<$>) :: (a -> b) -> f a -> f b
```

비슷하지만 일반 함수를 `f`로 감싼 타입입니다. 그렇다면 사용은 다음과 같이 할 수 있다.

```haskell
-- >>> (+1) <$> Just 1
-- Just 2

-- >>> Just (+1) <*> Just 1
-- Just 2
```

직관적으로 이해하기 어렵지만, 기억하면 좋을 것은 일반 함수를 쓰는데 인자 값들이 감싼 타입일 때 쓰면 좋다. `sumAges`는
`(+)`를 적용하는데 인자가 `Maybe Int`였기 때문에 어플리커티브를 쓰기 적절하다. 일반 함수를 `f (a -> b)`로 만들 때
보통 첫번째 인자에 펑터를 적용해서 다음과 같이 사용할 수 있다.

```haskell
sumAges :: Int -> Int -> Maybe Int
sumAges id1 id2 :: (+) <$> lookup id1 ages <*> lookup id2 ages
```

차근차근 보면 다음과 같다. `(+) <$> lookup id1 ages`는 무슨 타입인가? `\x y -> x + y <$> Maybe Int`일 것이다.
`Int` 타입은 `x`에 들어간다면 결과는 `x`가 부분 적용된 함수이다. 펑터의 결과는 일반 함수에 다시 `f`로 감싼 것이기 때문에 
결과 `(+)`의 나머지 인자를 받는 함수에 `Maybe`가 씌워진 `Maybe (Int -> Int)` 타입이 된다.

어플리커티브 타입 클래스에 많이 쓰는 함수 중 하나는 `pure`이다. `pure`는 모나드의 `return`과 같다. 많은 사람들이 `return`
보다 `pure`를 선호하는 것 같다. 이것이 조금 더 일반적인 버전이기 때문같다. 왜냐하면 `Monad`가 되려면 타입 생성자가 
`Applicative`여야 하는 제약이 있기 때문이다.

```haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
  ...
```

또 `Applicative`는 `Fuctor` 인스턴스가 있어야하는 제약이 있다.

```haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  ...
```

`Functor`는 다른 제약은 없다.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  ...
```

## 세미그룹

세미그룹은 효과와 직접적으로 관계는 없는 타입 클래스입니다. `Semigroup` 타입 클래스는 뭔가 합칠 수 있는 것들에 대한 추상입니다.
대표적인 인스턴스로 리스트 타입이 있습니다. 

```haskell
class Semigroup m where
  (<>) :: m -> m -> m
  ...
```

`String`도 리스트이기 때문에 다음과 같이 합칠 수 있습니다.

```haskell
-- >>> "Hello" <> " " <> "World"
-- "Hello World"
```

## 모노이드

모노이드는 세미그룹에 `mempty`가 있는 형태입니다. 세미그룹과 활용하여 `mempty`를 초기 값으로 활요할 수 있습니다.
`mappend`는 `(<>)`와 같지만 보통 `(<>)`를 많이 씁니다. 

```haskell
class Semigroup m => Monoid m where
  mempty :: m
  mappend :: a -> a -> a
```

리스트이 `mempty`는 `()` 빈 리스트입니다. 

```haskell
value :: [Int]
value = mempty [1, 2, 3]

-- >>> value
-- []
```

## Traverse

다음 값이 있을 때,

```haskell
ids :: [(String, Int)]
ids = [("John", 1), ("Jane", 2), ("Jim", 3)]

names :: [String]
names = ["John", "Jane", "Jim"]
```

다음 함수를 만들어라

```haskell
ages :: [Maybe Int]
```

그리고 다음 함수에 대해 생각해보시오.

```haskell
ages' :: Maybe [Int]
```

## Reader 모나드

## Writer 모나드

## State 모나드