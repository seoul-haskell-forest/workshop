# 하스켈 배움터 3일

## 펑터

### 타입 생성자와 리스트

리스트 타입인 `[]`도 사실 타입 생성자의 특별한 형태이다. `data List a = ...` 대신 `data [] a = ...`라고 볼 수 있고 
표기는 `[a]` 형태로 할 수 있다. 따라서 리스트 타입도 타입 변수가 하나 있는 타입 생성자이다.


### 실습 10

`mapOptional`은 타입 변수가 하나인 `Optional` 타입 생성자로 감싸있는 어떤 타입 `a`를 일반 함수를 적용해 `b`로 바꿀 수 
있는 함수였다. 이때 값이 `Null`이면 결과가 `Null`인 효과가 있었다. 마찬가지로 타입 변수가 하나인 `[]` 타입 생성자로 감싸있는 
`a` 타입에 일반 함수를 적용해 `b`로 바꾸는 함수를 만들 수 있다. `[]`의 특별한 효과는 항목에 모두 일반 함수를 적용하는 것이다.
다음 함수를 구현해보라. (힌트 지난 시간에 리스트 `map` 함수를 배웠다)

```haskell
mapList :: (a -> b) -> [a] -> [b]
```

### 펑터의 정의

`mapOptional`과 `mapList`는 비슷한 타입이다. 물론 구현은 다르다. 이 타입은 타입 변수가 하나인 어떤 타입 생성자에도 쓸 수 
있을 것같다. 타입 변수가 하나인 타입 생성자를 변수화 시키면 다음과 같은 추상을 얻을 수 있다.

```haskell
mapAll :: (a -> b) -> f a -> f b
```

이 함수에 `f` 변수를 타입 클래스로 추상화 하면 다음과 같은 타입 클래스를 정의 할 수 있다.

```haskell
class Mapable f where
	mapAll :: (a -> b) -> f a -> f b 
```

이제 어떤 타입 생성자 `f`에 `Mapable` 인스턴스가 있다면 `mapAll`을 사용할 수 있다. `mapAll`은 `f`로 감싼 타입 `a`에 
일반 함수를 적용해 `b`를 얻으면서 특별한 효과를 줄 수 있다. (Optional은 Null이 아닐 때만, []는 모든 항목에 적용)

### 실습 11

* `Optional` 타입 생성자의 `Mapable` 인스턴스를 만들기, 구현은 `mapOptional`과 같다.
* `[]` 타입 생성자의 `Mapable` 인스턴스 만들기, 구현은 `mapList`와 같다.

### 문제

`Int` 타입도 `Mapable` 인스턴스를 만들 수 있을까?

### 펑터의 의미와 Maybe 타입

펑터에서 `f a` 타입은 실제 값은 `a`이다. `f`는 효과를 위해 표시한 태그와 같다. `f`로 감싼 진짜 값인 `a`에 일반 함수를
적용 + 효과를 위한 타입 클래스다.

하스켈에서 `Mapable`과 같은 타입클래스를 `Functor`라고 한다. 다음과 같이 비슷하게 정의 되어 있다.

```haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b 
```

또 `Optional`은 하스켈에 `Maybe`로 다음과 같이 정의되어 있고 `Functor` 인스턴스도 있다. `[]` 역시 `Functor` 인스턴스가
있다.

```haskell
data Maybe a = Just a | Nothing
```

```haskell
-- >>> fmap inc (Just 1)
-- Just 2

-- >>> fmap inc Nothing
-- Nothing

-- >>> fmap (prefix "Hello") $ Just "World"
-- Just "Hello World"

-- >>> fmap inc [1, 2, 3]
-- [2,3,4]
```

`Functor`는 하스켈에서 중위 함수인 `<$>`로 많이 쓴다.

```haskell
-- >>> inc <$> (Just 1)
-- Just 2

-- >>> inc <$> [1, 2, 3]
-- [2,3,4]
```

### Either 타입

`Maybe` 타입은 어떤 계산 결과에 값이 없는 경우 많이 쓴다. `Maybe`와 마찬가지로 어떤 계산 결과가 올바르지 않은 경우에 오류
내용과 함께 전달 할 수 있는 `Either` 타입도 많이 쓴다. `Either` 타입은 다음과 같이 생겼다.

```haskell
data Either a b = Left a | Right b
```

```haskell
failValue :: Either String Int
failValue = Left "Invalid Number"

successValue :: Either String Int
successValue = Right 1
```

`Either`도 `Functor` 인스턴스가 있기 때문에 에러가 아닐 때(효과) 일반 함수를 적용할 수 있다. 

```haskell
-- >>> inc <$> successValue
-- Right 2

-- >>> inc <$> failValue
-- Left "Invalid Number"
```

### 생각해보기

펑터 타입 클래스의 `fmap`은 다음과 같이 정의 되어 있다. 정의 따르면 `f a`이기 때문에 `f`는 타입 변수가 하나 있어야 한다.
하지만 `Either`는 타입 변수가 두 개이다. 어떻게 `Functor` 인스턴스를 만들 수 있었을까?

```haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b 
```

## 모나드

모나드 예제를 알아보기 전에 하스켈에서 키와 값으로 데이터를 만들고 키로 값을 조회할 수 있는 방법에 대해 알아보자

하스켈은 튜플의 리스트를 다른 언어의 맵처럼 쓸 수 있다.

```haskell
ids :: [(String, Int)]
ids = [("Todd", 32), ("Eunmin", 424)]

-- >>> lookup "Todd" ids
-- Just 32
```

튜플의 첫번째 항목을 키로 `lookup` 함수를 부르면 Maybe 두번째타입 형태로 나온다. 키에 연결된 값이 없다면 `Nothing` 값이
나온다

### 실습 12

위에 `ids`에 들어 있는 값은 이름과 아이디 쌍이라고 하고 다음과 같이 아이디에 해당하는 나이가 있는 `ages` 데이터가 있다.

이 때 이름으로 나이를 조회할 수 있는 `getAge :: String -> Maybe Int` 함수를 구현하라. 이름에 해당하는 아이디가 없어나, 
아이디에 해당하는 나이가 없다면 `Nothing`을 돌려줘야 한다.

```haskell
ages :: [(Int, Int)]
ages = [(32, 100), (42, 50)]
```

### 펑터의 한계

위 실습 12에 펑터를 사용할 수 있을까?

```haskell
getAge :: String -> Maybe Int
getAge name = fmap (\id -> lookup id ages) (lookup name ids) -- 컴파일 에러!
```

펑터는 `lookup`의 결과에 다시 `lookup`을 적용할 수 없다. 왜냐하면 펑터에 쓸 수 있는 함수는 `a -> b`인 일반 함수이기
때문이다. 만약 `a -> b` 대신 `a -> f b`를 쓸 수 있다면 연속 적용할 수 있다. 모나드는 바로 다음과 같은 타입 클래스를 갖는다고
할 수 있다. 타입 변수는 모나드라는 이름 때문에 `f` 대신 `m`으로 썼다.

```haskell
class Monad m where
  bind :: (a -> m b) -> m a -> m b
```

이 함수는 `bind`라고 부르지만 실제 하스켈에서는 중위 함수로 되어 있다. 

```haskell
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
```

연속 적용의 편의를 위해 앞 쪽에 `m a` 뒤에 `a -> m b`를 뒀다. `Maybe` 타입의 모나드도 이미 구현되어 있기 때문에
`getAge`는 다음과 같이 만들 수 있다. `(>>=)`는 낮은 연산자 우선 순위를 갖고 있기 때문에 가장 나중에 계산되고 그래서 괄호
없이 쓸 수 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup name ids >>= \id -> lookup id ages
```

위 함수에서 만약 `lookup` 함수의 인자 순서가 반대라면 함수 부분 적용을 통해 아래와 같이 쓸 수 있었을 것이다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup ids name >>= lookup ages -- 컴파일 안됨!
```

하스켈에 편의 함수 중 인자 순서를 바꿔서 적용해주는 `flip`이라는 유틸리티 함수가 있다. 그것을 사용하면 아래와 같이 쓸 수 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = lookup name ids >>= flip lookup ages 
```

### 모나드의 좋은 점

펑터보다 모나드가 더 유연하고 좋다. 모나드 대신 펑터를 쓸 수 없지만 펑터 대신 모나드를 쓸 수 있다.

```haskell
-- >>> fmap (\x -> inc x) $ Just 1
-- Just 2

-- >>> Just 1 >>= (\x -> Just (inc x))
-- Just 2
```

모나드 안에서 일반 함수를 쓰되 결과 값을 Just로 감싸주면 되기 때문이다. 어떤 모나드에서 일반 함수를 쓸 때 일반 값을 모나드 값
으로 바꿀 때가 많기 때문에 모나드 타입 클래스에는 `return`이라는 함수가 있다.

```haskell
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
```

`return`은 일반 값을 받아서 모나드로 감싼 값을 만들어 준다. `Maybe` 모나드 값이라면 `return 1` 했을 때 `Just 1`이 된다.
그래서 위 예제는 다음과 같이 일반화 해서 쓸 수 있다. (* 주의, 자바같은 언어의 return과 이름만 같다)

```haskell
-- >>> Just 1 >>= (\x -> Just (inc x))
-- Just 2

-- >>> Just 1 >>= (\x -> return (inc x))
-- Just 2
```

### 실습 13

다음 값들을 이용해서 모나드를 활용해 `id` 값에 `inc`를 적용해 나이를 가져오는 `getAge'` 함수를 만들어라

```haskell
inc :: (Num a) -> a -> a
inc x = x + 1

ids :: [(String, Int)]
ids = [("Todd", 32), ("Eunmin", 424)]

ages :: [(Int, Int)]
ages = [(33, 100), (423, 50)]
```

### 실습 14

리스트도 모나드 인스턴스가 있다. 모나드를 이용해 숫자를 입력 받아 모든 항목에 `inc`를 적용하고 다시 모든 항목에 `show`를 
적용하는 `foo` 함수를 구현하라.

```haskell
foo :: [Int] -> [String]
```

### 맥락을 이어갈 수 있는 모나드

모나드는 펑터와 다르게 계산을 연속으로 이어나갈 수 있다. 그리고 연속된 계산에 효과(Maybe의 경우 Nothing이면 더 이상 계산하지 
않음)를 갖는다. 효과는 연속된 계산에 연속성을 갖을 수 있기 때문에 모나드는 맥락(Context)이 있다고 볼 수 있다. `(>>=)` 함수는
맥락에 따라 다른 동작을 한다.

### 모나드 편의 문법

모나드를 많이 쓰는 하스켈과 스칼라 언어에서는 모나드를 위한 문법 구문을 제공한다. 하스켈에서는 `do`, 스칼라에서는 `for`라고 한다.
다음은 위 실습 14 예제를 `do` 구문으로 바꿔쓴 것이다.

```haskell
getAge :: String -> Maybe Int
getAge name = do
  id <- lookup name ids
  id <- Just (inc id)
  lookup id ages
```

`do` 아래 순서대로 계산하는 여러 줄을 쓸 수 있다. `일반 값 <- 모나드 값` 형태로 모나드 값에서 일반 값을 꺼낸 형태로 왼쪽
심볼에 바인딩해준다. 바인딩이 되면 아래서 심볼로 일반 값을 참조해 쓸 수 있다. `do`의 마지막 값은 모나드 값이어야 한다.

`do` 구문 안에서는 `let 이름 = 값`으로 중간 계산 결과에 이름을 붙일 수 있는 편리한 기능도 있다.

```haskell
getAge :: String -> Maybe Int
getAge name = do
  id <- lookup name ids
  let result = inc id
  id <- Just result -- 조금 억지스러운 예제
  lookup id ages
```

## 실습 15

`ages`에서 아이디 두 개를 받아서 나이를 합치는 `sumAges` 함수를 작성하라

```haskell
sumAges :: Int -> Int -> Maybe Int
```

## 어플리커티브

위 실습 15에서 `sumAges`는 사실 앞의 계산과 뒤의 계산이 독립적이기 때문에 꼭 모나드를 쓸 필요가 없다. 이런 경우 어플리커티브
펑터를 사용하면 좋다. 다음은 `Applicative` 타입 클래스에 있는 `apply`라고 부르는 함수다.

```haskell
class Applicative f where
  (<*>) :: f (a -> b) -> f a -> f b
```

펑터와 비교해 봅시다.

```haskell
(<$>) :: (a -> b) -> f a -> f b
```

비슷하지만 일반 함수를 `f`로 감싼 타입입니다. 그렇다면 사용은 다음과 같이 할 수 있다.

```haskell
-- >>> (+1) <$> Just 1
-- Just 2

-- >>> Just (+1) <*> Just 1
-- Just 2
```

직관적으로 이해하기 어렵지만, 기억하면 좋을 것은 일반 함수를 쓰는데 인자 값들이 감싼 타입일 때 쓰면 좋다. `sumAges`는
`(+)`를 적용하는데 인자가 `Maybe Int`였기 때문에 어플리커티브를 쓰기 적절하다. 일반 함수를 `f (a -> b)`로 만들 때
보통 첫번째 인자에 펑터를 적용해서 다음과 같이 사용할 수 있다.

```haskell
sumAges :: Int -> Int -> Maybe Int
sumAges id1 id2 :: (+) <$> lookup id1 ages <*> lookup id2 ages
```

차근차근 보면 다음과 같다. `(+) <$> lookup id1 ages`는 무슨 타입인가? `\x y -> x + y <$> Maybe Int`일 것이다.
`Int` 타입은 `x`에 들어간다면 결과는 `x`가 부분 적용된 함수이다. 펑터의 결과는 일반 함수에 다시 `f`로 감싼 것이기 때문에 
결과 `(+)`의 나머지 인자를 받는 함수에 `Maybe`가 씌워진 `Maybe (Int -> Int)` 타입이 된다.

어플리커티브 타입 클래스에 많이 쓰는 함수 중 하나는 `pure`이다. `pure`는 모나드의 `return`과 같다. 많은 사람들이 `return`
보다 `pure`를 선호하는 것 같다. 이것이 조금 더 일반적인 버전이기 때문같다. 왜냐하면 `Monad`가 되려면 타입 생성자가 
`Applicative`여야 하는 제약이 있기 때문이다.

```haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a
  ...
```

또 `Applicative`는 `Fuctor` 인스턴스가 있어야하는 제약이 있다.

```haskell
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  ...
```

`Functor`는 다른 제약은 없다.

```haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  ...
```

## 세미그룹

세미그룹은 효과와 직접적으로 관계는 없는 타입 클래스입니다. `Semigroup` 타입 클래스는 뭔가 합칠 수 있는 것들에 대한 추상입니다.
대표적인 인스턴스로 리스트 타입이 있습니다. 

```haskell
class Semigroup m where
  (<>) :: m -> m -> m
  ...
```

`String`도 리스트이기 때문에 다음과 같이 합칠 수 있습니다.

```haskell
-- >>> "Hello" <> " " <> "World"
-- "Hello World"
```

## 모노이드

모노이드는 세미그룹에 `mempty`가 있는 형태입니다. 세미그룹과 활용하여 `mempty`를 초기 값으로 활요할 수 있습니다.
`mappend`는 `(<>)`와 같지만 보통 `(<>)`를 많이 씁니다. 

```haskell
class Semigroup m => Monoid m where
  mempty :: m
  mappend :: a -> a -> a
```

리스트이 `mempty`는 `()` 빈 리스트입니다. 

```haskell
value :: [Int]
value = mempty [1, 2, 3]

-- >>> value
-- []
```

## Traverse

다음 값이 있을 때,

### 실습 16

```haskell
ids :: [(String, Int)]
ids = [("John", 1), ("Jane", 2), ("Jim", 3)]

names :: [String]
names = ["John", "Jane", "Jim"]
```

다음 함수를 만들어라

```haskell
ages :: [Maybe Int]
```

### 실습 17

그리고 다음 함수에 만들어보시오.

```haskell
ages' :: Maybe [Int]
```

## 자주 쓰는 모나드

모나드는 맥락 속에서 연속된 계산을 한다. `Maybe` 모나드인 경우 계산 중 결과가 `Nothing` 값이 나오면 다음 계산으로 이어지지
않는 맥락을 갖는다. 자주 쓰는 다른 모나드를 보자.

### Reader

모나드 계산 중에 언제나 외부 값을 불러서 쓸 수 있는 효과가 있는 모나드 만들기

#### 실습 18

어떤 타입 `r`을 인자로 받고 어떤 다른 타입 `a`를 돌려주는 함수 값 `r -> a`를 갖는 `Config r a` 타입을 레코드 타입으로 
정의하라.

#### 실습 19
실습 18에서 만든 `Config r a`에 효과를 만들 것이다. `r`은 외부 값, `a`가 진짜 값이라고 할때, `42`라는 진짜 값을
갖는 `Config r a` 값을 만들고 진짜 값을 꺼내보자. `r`은 아무 값이나 넣어라.

#### 실습 20
앞에 실습에서 `r` 값을 사용하는 `Config r a` 값을 만들어보라.

#### 실습 21

다음과 같이 `Config` 타입에 펑터 인스턴스를 만들어 보자. `Config` 타입의 펑터는 일반 값인 `a`를 꺼내서 `f`를 적용하고
다시 `Config`로 감싸주는 함수다. 인스턴스에 시그니처를 쓰기 위해 `{-# LANGUAGE InstanceSigs #-}` 언어 확장을 추가했다.

```haskell
instance Functor (Config r) where
  fmap :: (a -> b) -> Config r a -> Config r b
  fmap f x = undefined
```

#### 실습 22

`Config Int String` 값을 만들고 펑터에 `<$>`를 이용해서 일반 함수 `("Hello " ++)`를 적용해 최종 결과인 `a` 값을
꺼내보라.

`Config`의 모나드 인스턴스를 만들어보자. 앞에서 본 것 처럼 모나드 인스턴스가 되려면 `Applicative` 인스턴스가 필요하다.
다음은 `Config`의 `Applicative` 인스턴스다.

```haskell
instance Applicative (Config r) where
  pure x = Config $ \_ -> x
  (<*>) :: Config r (a -> b) -> Config r a -> Config r b
  (<*>) (Config f) (Config x) = Config $ \r -> f r (x r)
```

다음은 `Applicative`를 사용하는 예이다.

```haskell
result2 :: Config Int String
result2 = (++) <$> Config (\r -> show (r + 1)) <*> Config (\r -> show (r + 2))

-- >>> runConfig result2 1
-- "23"
```

펑터와 어플리커티브에서 `r` 값은 `Config` 안에 있는 계산에서만 쓸 수 있었다. 모나드는 계산 과정을 중첩할 수 있기 때문에 
`Config`의 어떤 계산 과정에서도 `r` 값을 쓸 수 있을 것이다.

#### 실습 23

`Config`에 대한 모나드 인스턴스를 구현하라

```haskell
instance Monad (Config r) where
  return = pure
  (>>=) :: Config r a -> (a -> Config r b) -> Config r b
  (>>=) = undefined
```

`Config` 모나드로 계산을 이어 붙이면 계산 과정 중 필요하다면 언제든 `r` 값을 쓸 수 있다.

```haskell
result3 :: Config Int String
result3 = Config (\r -> 42) >>= \x -> Config (\r -> r) >>= \config -> pure $ "Result: " ++ show (x + config)

-- >>> runConfig result3 1
-- "Result: 43"
```

`do` 구문으로 쓰면 다음과 같다.

```haskell
result4 :: Config Int String
result4 = do
  x <- pure 42
  config <- Config (\r -> r)
  pure $ "Result: " ++ show (x + config)

-- >>> runConfig result4 1
-- "Result: 43"
```

하스켈에서는 이 `Config` 모나드의 구현을 `Reader`라고 한다.

### 의존성 추가하기

하스켈에서는 `Reader` 모나드가 `mtl` 또는 `transformers` 패키지에 구현되어 있다.
의존성을 추가하기 위해 `package.yaml` 파일을 열어 `mtl` 패키지를 다음과 같이 추가한다.

```yaml
dependencies:
- base >= 4.7 && < 5
- mtl
```

패키지를 추가하고 VSCode에서 활성화 하려면 VScode를 재시작하거나 `Haskell: Restart LSP Server` 명령어로 `HLS`를
재시작해주면 된다.

`mtl` 패키지에 `Reader` 모나드는 `Control.Monad.Reader` 모듈에 있다.

```haskell
import Control.Monad.Reader (Reader, ask, runReader)
```

`Reader r a` 타입은 실습에서 만든 것처럼 `r` 타입을 `ask` 함수로 모나드 안에서 가져올 수 있다.

```haskell
example :: Reader Int String
example = do
  x <- ask
  pure $ "Value: " ++ show x
```

### 실습 24

다음 `app` 값을 Bool 타입의 `isDeveMode` 값을 전역 값 대신 `Reader` 모나드로 읽어오도록 코드를 고쳐라

```haskell
isDevMode = True

app :: Int 
app = 
  result
  where 
    x = 40
    y = if isDevMode then 0 else 2
    result = x + y
```

### Writer

`Reader`와 비슷하지만 맥락에 값을 기록 할 수 있는 `Write` 모나드가 있다. `tell` 함수로 기록 한다.

```haskell
import Control.Monad.Writer (Writer, tell, runWriter)

app :: Writer [String] Int
app = do
    let x = 40
    let y = 2
    tell ["y=" ++ show y]
    return $ x + y
```

기록 한 값은 `runWriter`를 했을 때 결과와 함께 나온다.

```haskell
-- >>> (result, logs) = runWriter app
```

### State

`Reader`와 `Writer` 기능을 함께 갖고 있는 `State` 모나드가 있다. 모나드 안에서 상태가 있는 값을 흉내낼 수 있다.

```haskell
import Control.Monad.State (State, get, put, runState)

app :: State Int Int
app = do
  let x = 40
  value <- get
  put $ value + 1
  value <- get
  put $ value + 1
  value <- get
  return $ x + value

-- >>> (result, state) = runState app 0
```

### IO

입출력을 담당하는 `IO`도 모나드이다. `IO` 모나드가 하는 일은 거의 없다. `IO`는 모나드 맥락에서 부수 효과를 모으는 역할을
한다. 부수 효과를 모두 모아서 `IO` 맥락에 담아서 `main` 함수에 전달하면 `main` 함수는 부수 효과를 실제로 발생시키는 역할을 
한다.

```haskell
import System.Environment (getArgs)

app :: IO Int
app = do
  (x:_) <- getArgs -- 커맨드 라인 입력 값을 문자열 리스트로 가져오는 부수 효과를 모아 둔다.
  let y = "Arg: " ++ x
  _ <- print y -- 화면에 출력하는 부수효과를 모은다. print의 리턴 타입은 IO () 이다.
  pure 0

main :: IO () -- IO 모나드로 모은 모든 부수효과를 순서대로 처리한다
main = do 
  x <- app
  print x -- x 값을 화면에 출력하는 부수 효과를 모은다
```